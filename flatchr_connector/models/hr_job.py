from datetime import datetime
from odoo import fields, models
import requests
import json
from odoo.exceptions import ValidationError
import logging

_logger = logging.getLogger(__name__)

class HrJob(models.Model):
    _inherit = 'hr.job'
    
    flatchr_job_id = fields.Char(string='Flatchr job ID') # unique ID generated by Flatchr
    description = fields.Html(string='Description')
    requirements = fields.Html(string='Requirements')

    def parse_vacancy(self, vacancy_dict : dict)-> dict:
        existing_jobs = self.env['hr.job'].search([('flatchr_job_id', '=', vacancy_dict['id'])])

        content_dict = {
            'flatchr_job_id': vacancy_dict['id'],
            'name': vacancy_dict['title'],
            'description': vacancy_dict['description'],
            'requirements': vacancy_dict['profile'],
            'state': 'recruit' if vacancy_dict['status'] == 1 else 'open'
        }

        if not existing_jobs:
            vacancy_id = self.env['hr.job'].create(content_dict)
        else:
            vacancy_id = existing_jobs[0]
            vacancy_id.write(content_dict)

        return {
            vacancy_dict['title']: vacancy_id
        }

    def parse_applicant(self, applicant : dict, vacancy_ids : dict):
        # Before even considering updating/creating hr_applicant, one needs to make sure the corresponding res.partner exists/is updated
        existing_partners = self.env['res.partner'].search([('flatchr_applicant_id', '=', json.dumps(applicant['applicant']))])
        content_dict = {
            'flatchr_applicant_id': applicant['applicant'],
            'name': f"{applicant['firstname']} {applicant['lastname']}",
            'email': applicant['email'],
            'phone': applicant['phone'],
        }
        if not existing_partners:
            partner_id = self.env['res.partner'].create(content_dict)
        else:
            existing_partners[0].write(content_dict)
            partner_id = existing_partners[0]

        # Then we can take care of the hr_applicant
        existing_applicants = self.env['hr.applicant'].search([('flatchr_applicant_id', '=', applicant['applicant'])])
        content_dict = {
            'name': f"{applicant['firstname']} {applicant['lastname']} (Flatchr)",
            'flatchr_applicant_id': applicant['applicant'],
            'create_date': applicant['created_at'],
            'partner_id': partner_id.id,
            'applicant_source': applicant['source'],
            'date_store': datetime.now(),
            'job_id': vacancy_ids[applicant['vacancy']].id
        }
        if not existing_applicants:
            self.env['hr.applicant'].create(content_dict)
        else:
            existing_applicants[0].write(content_dict)

    def fetch_flatchr_data(self):
        slug = self.env['ir.config_parameter'].sudo().get_param('flatchr_connector.flatchr_enterprise_slug')
        token = self.env['ir.config_parameter'].sudo().get_param('flatchr_connector.flatchr_api_key')
        company_key = self.env['ir.config_parameter'].sudo().get_param('flatchr_connector.flatchr_company_key')

        vacancy_ids = {} # Those silly goobers don't know how to reference records properly using ids, so I have to identify them DIY-style using a title.

        # Start by updating all jobs FIRST to make sure all applicants are tied to existing jobs
        # and not the other way around
        response = requests.get(f'https://careers.flatchr.io/company/{slug}.json', headers = {
            'Accept': '*/*',
            'Authorization': f'Bearer {token}'
        })

        for vacancy in response.json()['items']:
            if vacancy['vacancy']:
                vacancy_ids.update(self.parse_vacancy(vacancy['vacancy']))

        # Now, retrieve and parse applicants
        response = requests.post(f'https://api.flatchr.io/company/{company_key}/search/applicants', headers={
            'Accept': '*/*',
            'Authorization': f'Bearer {token}',
        }, data={
            'company': company_key,
        })
        
        _logger.info("******************* %s" %response)

        #for applicant in response.json(): self.parse_applicant(applicant, vacancy_ids)
